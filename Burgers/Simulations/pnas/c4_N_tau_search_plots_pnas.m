clear all; close all; clc;

addpath ../../simulation_functions/
addpath ../../nonlinear/
addpath ../../analysis/

set(groot,'defaultAxesTickLabelInterpreter','latex');
set(groot,'defaulttextinterpreter','latex');
set(groot,'defaultLegendInterpreter','latex');

style{1} = 'k-o';
style{2} = 'k-*';
style{3} = 'k-+';
style{4} = 'k-s';
style{5} = 'k-x';
style{6} = 'k-^';
style{7} = 'k->';
style{8} = 'k-<';
style{9} = 'k-p';
style{10} = 'k-h';

N_full = 16384;
alpha = 1;
epsilon = 1;
endtime = 1;
N_list = 6:2:14;
tau_list = [-1:0.01:1];
t_slope_start = 15;
t_slope_end = 500;

% This data is generated by running the create_data_spec procedure and with saving the output at a dt of 1e-1
load('u_list_M_16384_N_14_t_10_1e1.mat')
load('t_list_M_16384_N_14_t_10_1e1.mat')

% Create the "full" spectral solution data or load it
if ~(exist(sprintf(['u_list_M_' num2str(N_full) '_endtime_' num2str(endtime) '_inveps_' num2str(1/epsilon) '.mat']),'file') == 2)
    
    [t_list,u_list] = create_data_spec(alpha,N_full,endtime,epsilon);
    
    save(['u_list_M_' num2str(N_full) '_endtime_' num2str(endtime) '_inveps_' num2str(1/epsilon) '.mat'],'u_list','-v7.3')
    save(['t_list_M_' num2str(N_full) '_endtime_' num2str(endtime) '_inveps_' num2str(1/epsilon) '.mat'],'t_list','-v7.3')
    
else
    
    load(['u_list_M_' num2str(N_full) '_endtime_' num2str(endtime) '_inveps_' num2str(1/epsilon) '.mat'],'u_list')
    load(['t_list_M_' num2str(N_full) '_endtime_' num2str(endtime) '_inveps_' num2str(1/epsilon) '.mat'],'t_list')
    
end

% Find the resolved snapshots & trim the time and solution arrays or load
% the snapshot listing - this can be uncommented once we settle on final
% resolved criteria
if ~(exist(sprintf(['viable_snapshots_M_' num2str(N_full) '_endtime_' num2str(endtime) '_inveps_' num2str(1/epsilon) '.mat']),'file') == 2)
    
    [viable_snapshots,tmodel_size_list,tmodel_size_list_full] = resolve_array(u_list,t_list,alpha);
    
    save(['viable_snapshots_M_' num2str(N_full) '_endtime_' num2str(endtime) '_inveps_' num2str(1/epsilon) '.mat'],'viable_snapshots');
    save(['tmodel_size_list_M_' num2str(N_full) '_endtime_' num2str(endtime) '_inveps_' num2str(1/epsilon) '.mat'],'tmodel_size_list');
    save(['tmodel_size_list_full_M_' num2str(N_full) '_endtime_' num2str(endtime) '_inveps_' num2str(1/epsilon) '.mat'],'tmodel_size_list_full');
    
else
    
    load(['viable_snapshots_M_' num2str(N_full) '_endtime_' num2str(endtime) '_inveps_' num2str(1/epsilon) '.mat'],'viable_snapshots');
    load(['tmodel_size_list_M_' num2str(N_full) '_endtime_' num2str(endtime) '_inveps_' num2str(1/epsilon) '.mat'],'tmodel_size_list');
    load(['tmodel_size_list_full_M_' num2str(N_full) '_endtime_' num2str(endtime) '_inveps_' num2str(1/epsilon) '.mat'],'tmodel_size_list_full');
    
end

% Trim the solution arrays
u_list = u_list(:,viable_snapshots);
t_list = t_list(viable_snapshots);

% Calculate the renromalization coefficients and corresponding error for
% tau_list
[c1_data,c2_data,c3_data,c4_data] = renormalize(alpha,N_list,u_list,t_list,tau_list);

% Extract variables from renormalize data structure
c4_op = c4_data.c4_op;

% Simulations and plots using tau corresponding to the minimum error from tau search
endtime = 1000;
howoften = 1000;
num_points = 10000;
dt = 1e-4;

% Create the exact upwind data or create it
if ~(exist(sprintf(['u_list_' num2str(endtime) '_num_points_' num2str(num_points) '_invdt_' num2str(1/dt) '_inveps_' num2str(1/epsilon) '.mat']),'file') == 2)
    [t_list,u_list,u_list_real] = create_data(alpha,num_points,endtime,dt,howoften,epsilon);
    
else
    load(['u_list_' num2str(endtime) '_num_points_' num2str(num_points) '_invdt_' num2str(1/dt) '_inveps_' num2str(1/epsilon) '.mat'],'u_list');
    load(['t_list_' num2str(endtime) '_num_points_' num2str(num_points) '_invdt_' num2str(1/dt) '_inveps_' num2str(1/epsilon) '.mat'],'t_list');
    load(['u_list_real_' num2str(endtime) '_num_points_' num2str(num_points) '_invdt_' num2str(1/dt) '_inveps_' num2str(1/epsilon) '.mat'],'u_list_real');

end

% Create empty dictionaries
tc4B{1,length(N_list)} = [];
uc4B{1,length(N_list)} = [];
energyc4B{1,length(N_list)} = [];
errc4B{1,length(N_list)} = [];
dE_exact{1,length(N_list)} = [];
R0{1,length(N_list)} = [];
R1{1,length(N_list)} = [];
R2{1,length(N_list)} = [];
R3{1,length(N_list)} = [];
R4{1,length(N_list)} = [];
RTS{1,length(N_list)} = [];

% Preallocate arrays
errc4B_val = zeros(length(N_list),1);

% n = 4 ROMs
for i = 1:length(N_list)
    
    N = N_list(i);
    
    simulation_params.N = N;
    simulation_params.epsilon = epsilon;
    simulation_params.alpha = alpha;
    simulation_params.tau = c4_op(5,i);
    simulation_params.endtime = endtime;
    simulation_params.print_time = 1;
    simulation_params.time_range = t_list;
    simulation_params.degree = 4;
    simulation_params.coeffs = c4_op(1:4,i);
    simulation_params.initialization = @(x) ROM_init_Burgers(x);
    [tc4B{i},uc4B{i}] = ROM_PDE_solve(simulation_params);
    
    energy_exact = get_energy(u_list,N);
    energyc4B{i} = get_energy(uc4B{i},N);
    
    u_exact = u_list(1:N,:);
    errc4B{i} = ((get_energy(uc4B{i}(:,1:length(tc4B{i})) - u_exact(:,1:length(tc4B{i})),N))./get_energy(u_exact(:,1:length(tc4B{i})),N)).';
    
    
    if length(tc4B{i}) > 0
        errc4B_val(i) = (1/tc4B{i}(end))*trapz(tc4B{i},errc4B{i});
    else
        errc4B_val(i) = 0;
    end
    
    [R0{i},R1{i},R2{i},R3{i},R4{i},RTS{i}] = ROM_dE_memory(c4_op(:,i),N,tc4B{i},uc4B{i},alpha);
    
    dE_exact{i} = second_order_diff(t_list,energy_exact);

end

% Calculate the slopes
cfitexact = polyfit(log(t_list(find(t_list == t_slope_start):find(t_list == t_slope_end))).',log(energy_exact(find(t_list == t_slope_start):find(t_list == t_slope_end))), 1);

energy_full = get_energy(u_list_M_16384_N_14_t_10_1e1,N_list(end));

figure()
hold on
for i = 1:length(N_list)
    
    cfitROM = polyfit(log(tc4B{i}(find(tc4B{i} == t_slope_start):find(tc4B{i} == t_slope_end))),log(energyc4B{i}(find(tc4B{i} == t_slope_start):find(tc4B{i} == t_slope_end))), 1);

    even_log_space = exp(linspace(-2,log(tc4B{i}(end)),50));
    indexes = zeros(length(even_log_space),1);
    for j = 1:length(even_log_space)
        [~,min_loc] = min(abs(tc4B{i} - even_log_space(j)));
        indexes(j) = min_loc;
    end
    
    t_e = tc4B{i}(indexes);
    energy_e = energyc4B{i}(indexes);
    
    txt = ['Fourth order $N$ = ' num2str(N_list(i)) ' ROM: slope = ' num2str(cfitROM(1),'%3.2f')];
    plot(log(t_e),log(energy_e),style{i},'DisplayName',txt)
    box on
    xlim([-2,log(t_e(end))])
    ylim([-14,0])
    xlabel('Log(Time)','fontsize',16)
    ylabel('Log(Energy)','fontsize',16)
    
    clear t_e energy_e cfitROM
    
end

plot(log(t_list),log(energy_exact),'k--','linewidth',2,'DisplayName',['Second-order upwind solution: slope = ' num2str(cfitexact(1),'%3.2f')])

indexes = zeros(length(find(even_log_space <= 10)),1);
for j = 1:length(find(even_log_space <= 10))
    [~,min_loc] = min(abs(t_list_M_16384_N_14_t_10_1e1 - even_log_space(j)));
    indexes(j) = min_loc;
end

t_e_full = t_list_M_16384_N_14_t_10_1e1(indexes);
energy_e_full = energy_full(indexes);

plot(log(t_e_full),log(energy_e_full),style{10},'DisplayName',"$M'$ = 16384 spectral solution")

hold off
legend('location','southwest')
saveas(gcf,sprintf('Burgers_energy_multiple_N_%i_to_%i_test',N_list(1),N_list(end)),'eps')

figure()
hold on
for i = 1:length(N_list)
    
    even_space = linspace(0,tc4B{i}(end),50);
    indexes = zeros(length(even_space),1);
    for j = 1:length(even_space)
        [~,min_loc] = min(abs(tc4B{i} - even_space(j)));
        indexes(j) = min_loc;
    end
    
    t_e = tc4B{i}(indexes);
    error_e = errc4B{i}(indexes);

    txt = ['Fourth order $N$ = ' num2str(N_list(i)) ' ROM'];
    plot(t_e,error_e,style{i},'DisplayName',txt)
    box on
    xlim([0,t_e(end)])
    ylim([0,0.2])
    xlabel('Time','fontsize',16)
    ylabel('Error','fontsize',16)
    
    clear t_e error_e
    
end

hold off
legend('location','northwest')
saveas(gcf,sprintf('Burgers_error_multiple_N_%i_to_%i_test',N_list(1),N_list(end)),'eps')

% Plot the change in energy of each memory term for each N
load(['u_list_real_' num2str(endtime) '_num_points_' num2str(num_points) '_invdt_' num2str(1/dt) '_inveps_' num2str(1/epsilon) '.mat'],'u_list_real');

N = 14;
t_list_ROM = tc4B{find(N_list == N)}.';
R1_ROM = R1{find(N_list == N)}.';
R2_ROM = R2{find(N_list == N)}.';
R3_ROM = R3{find(N_list == N)}.';
R4_ROM = R4{find(N_list == N)}.';
RT_ROM = (R1_ROM+R2_ROM+R3_ROM+R4_ROM).';
RTS = trapz(t_list_ROM,RT_ROM);
RT_exact = dE_exact{find(N_list == N)}.';
RTS_exact = trapz(t_list,RT_exact);

even_log_space = exp(linspace(-2,log(t_list_ROM(end)),150));
indexes = zeros(length(even_log_space),1);
for j = 1:length(even_log_space)
    [~,min_loc] = min(abs(t_list_ROM - even_log_space(j)));
    indexes(j) = min_loc;
end

t_e = t_list_ROM(indexes);
R1_e = R1_ROM(indexes);
R2_e = R2_ROM(indexes);
R3_e = R3_ROM(indexes);
R4_e = R4_ROM(indexes);

figure()
hold on
plot(log(t_e),R1_e,style{2},'DisplayName','$\frac{1}{2} \sum_{k \in F} \alpha_1(t) t^1 \Delta E^1_k(t)$')
plot(log(t_e),R2_e,style{3},'DisplayName','$\frac{1}{2} \sum_{k \in F} \alpha_2(t) t^2 \Delta E^2_k(t)$')
plot(log(t_e),R3_e,style{4},'DisplayName','$\frac{1}{2} \sum_{k \in F} \alpha_3(t) t^3 \Delta E^3_k(t)$')
plot(log(t_e),R4_e,style{5},'DisplayName','$\frac{1}{2} \sum_{k \in F} \alpha_4(t) t^4 \Delta E^4_k(t)$')
plot(log(t_list_ROM),RT_ROM,'k-.','linewidth',2,'DisplayName','$\frac{1}{2}  \sum_{i=1}^4 \sum_{k \in F} \alpha_i(t) t^i \Delta E^i_k(t)$')
plot(log(t_list_ROM),RT_exact,'k--','linewidth',2,'DisplayName',['Second-order upwind solution'])
box on
xlim([-2,log(t_e(end))])
ylim([-0.4,0.4])
xlabel('Log(Time)','fontsize',16)
ylabel('Contribution to energy rate of change','fontsize',16)
hold off
legend('location','northeast')

saveas(gcf,sprintf('Burgers_memory_energy_N_%i_tau_optimal_test',N),'eps')
    
% Plot all the ROM in real space
N = 14;
t_list_ROM = tc4B{find(N_list == N)}.';
u_list_ROM = uc4B{find(N_list == N)};

% Create full Fourier array for full model for t = 10 from resolved data
u_full_ROM = zeros(2*N,length(t_list_ROM));
u_full_ROM(1:N,:) = u_list_ROM;
u_full_ROM(N+2:2*N,:) = conj(flipud(u_list_ROM(2:N,:)));
x = linspace(0,2*pi*(2*N)/(2*N),2*N+1);

% Create full array for upwinding
N_up = size(u_list,1);
x_up = linspace(0,2*pi*(num_points)/(num_points),num_points+1);

figure()
for i = 1:find(t_list_ROM == 10) 
    
    u_F_ROM = ifft_norm(u_full_ROM(:,i));
    u_F_ROM_np = [u_F_ROM(:);u_F_ROM(1)];
    u_real = u_list_real(:,i);
    u_real_np = [u_real(:);u_real(1)];
    
    time_c = round(t_list_ROM(i),1);
    
    p = plot(x,u_F_ROM_np,style{5},x_up,u_real_np,'k--');
    
    p(2).LineWidth = 2;
    xlim([x_up(1),x_up(end)])
    ylim([-1.5,1.5])
    xlabel('x','fontsize',16)
    ylabel('u','fontsize',16)
    legend(['Fourth order $N$ = ' num2str(N) ' ROM'],['Second-order upwind solution'])
    pause(0.005)
    
    if time_c == 0.1 || time_c == 0.5 || time_c == 1.0 || time_c == 1.1 || time_c == 1.2 || time_c == 1.3 || time_c == 1.4 || time_c == 1.5 || time_c == 5.0 || time_c == 10.0 || time_c == 25.0 || time_c == 50.0 || time_c == 75.0 || time_c == 100.0
        
        saveas(gcf,sprintf('Burgers_real_space_N_%i_tau_optimal_time_x_10_%s_test',N,num2str(t_list(i)*10)),'eps')
        
    end
    
end